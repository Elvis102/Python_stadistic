
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3. More Python Concepts &#8212; Learning Statistics with Python</title>
    
  <link rel="stylesheet" href="_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/sphinx-book-theme.e7340bb3dbd8dde6db86f25597f54a1b.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.7d483ff0a819d6edff12ce0b1ead3928.js"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="1. Descriptive statistics" href="03.01-descriptives.html" />
    <link rel="prev" title="1. Getting Started with Python" href="02.01-getting_started_with_python.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="index.html">
  
  
  <h1 class="site-logo" id="site-title">Learning Statistics with Python</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="landingpage.html">
   Learning Statistics with Python
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Part I. Background
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="01.01-intro.html">
   1. Why do we learn statistics?
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="01.02-studydesign.html">
   2. A brief introduction to research design
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Part II. An Introduction to Python
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="02.01-getting_started_with_python.html">
   1. Getting Started with Python
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="02.01-getting_started_with_python.html#typing-commands-at-the-python-console">
   2. Typing commands at the Python console
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   3. More Python Concepts
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Part III. Working With Data
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="03.01-descriptives.html">
   1. Descriptive statistics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="03.02-drawing_graphs.html">
   2. Drawing Graphs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="03.03-pragmatic_matters.html">
   3. Pragmatic Matters
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="03.04-basic_programming.html">
   4. Basic Programming
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Part IV. Statistical Theory
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="04.01-intro-to-probability.html">
   1. Statistical theory
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="04.02-probability.html">
   2. Introduction to Probability
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="04.03-estimation.html">
   3. Estimating unknown quantities from a sample
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="04.04-hypothesis-testing.html">
   4. Hypothesis Testing
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Part V. Statistical Tools
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="05.01-chisquare.html">
   1. Categorical data analysis
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="05.02-ttest.html">
   2. Comparing Two Means
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="05.03-anova.html">
   3. Comparing several means
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="05.04-regression.html">
   4. Linear regression
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="05.05-anova2.html">
   5. Factorial ANOVA
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Part VI. Endings, Alternatives and Prospects
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="06.01-bayes.html">
   1. Bayesian Statistics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="06.02-epilogue.html">
   2. Epilogue
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="bibliography.html">
   3. References
  </a>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/02.02-more_python_concepts.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/ethanweed/pythonbook"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/ethanweed/pythonbook/issues/new?title=Issue%20on%20page%20%2F02.02-more_python_concepts.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>


            <!-- Full screen (wrap in <a> to have style consistency -->
            <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                    data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                    title="Fullscreen mode"><i
                        class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/ethanweed/pythonbook/https://github.com/ethanweed/pythonbook/tree/main/Chapters?urlpath=tree/02.02-more_python_concepts.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i>
            Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#using-comments">
   3.1. Using comments
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#installing-and-importing">
   3.2. Installing and importing
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#what-libraries-does-this-book-use">
     3.2.1. What libraries does this book use?
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#importing-libraries">
     3.2.2. Importing libraries
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#listing-the-objects-in-active-memory">
   3.3. Listing the objects in active memory
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#removing-variables-from-the-workspace">
     3.3.1. Removing variables from the workspace
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#loading-and-saving-data">
   3.4. Loading and saving data
  </a>
 </li>
</ul>

        </nav>
        
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="more-python-concepts">
<h1><span class="section-number">3. </span>More Python Concepts<a class="headerlink" href="#more-python-concepts" title="Permalink to this headline">¶</a></h1>
<blockquote id="mechanics">
<div><p><em>Form follows function</em></p>
<p>– Louis Sullivan</p>
</div></blockquote>
<p>In the chapter on <a class="reference internal" href="02.01-getting_started_with_python.html#getting-started-with-python"><span class="std std-ref">Getting started with Python</span></a> our main goal was to, well, get started with Python. As we go through the book we’ll run into a lot of new  Python concepts, which I’ll explain alongside the relevant data analysis concepts. However, there’s still quite a few things that I need to talk about now, otherwise we’ll run into problems when we start trying to work with data and do statistics. So that’s the goal in this chapter: to build on the introductory content from the last chapter, to get you to the point that we can start using Python for statistics. Broadly speaking, the chapter comes in two parts. The first half of the chapter is devoted to the “mechanics” of Python: installing and loading packages, managing the workspace, navigating the file system, and loading and saving data. In the second half, I’ll talk more about what kinds of variables exist in Python, and introduce three new kinds of variables: factors, data frames and formulas. I’ll finish up by talking a little bit about the help documentation in Python as well as some other avenues for finding assistance. In general, I’m not trying to be comprehensive in this chapter, I’m trying to make sure that you’ve got the basic foundations needed to tackle the content that comes later in the book. However, a lot of the topics are revisited in more detail later.</p>
<div class="section" id="using-comments">
<h2><span class="section-number">3.1. </span>Using comments<a class="headerlink" href="#using-comments" title="Permalink to this headline">¶</a></h2>
<p>Before discussing any of the more complicated stuff, I want to introduce the <strong><em>comment</em></strong> character, <code class="docutils literal notranslate"><span class="pre">#</span></code>. It has a simple meaning: it tells Python to ignore everything else you’ve written on this line. You won’t have much need of the <code class="docutils literal notranslate"><span class="pre">#</span></code> character immediately, but it’s very useful later on when writing scripts. However, while you don’t need to use it, I want to be able to include comments in my Python extracts. For instance, if you read this: <a class="footnote-reference brackets" href="#note1" id="id1">1</a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">seeker</span> <span class="o">=</span> <span class="mf">3.1415</span>           <span class="c1"># create the first variable</span>
<span class="n">lover</span> <span class="o">=</span> <span class="mf">2.7183</span>            <span class="c1"># create the second variable</span>
<span class="n">keeper</span> <span class="o">=</span> <span class="n">seeker</span> <span class="o">*</span> <span class="n">lover</span>   <span class="c1"># now multiply them to create a third one</span>
<span class="nb">print</span><span class="p">(</span> <span class="n">keeper</span> <span class="p">)</span>           <span class="c1"># print out the value of &#39;keeper&#39;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>8.539539450000001
</pre></div>
</div>
</div>
</div>
<p>it’s a lot easier to understand what I’m doing than if I just write this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">seeker</span> <span class="o">=</span> <span class="mf">3.1415</span>
<span class="n">lover</span> <span class="o">=</span> <span class="mf">2.7183</span>
<span class="n">keeper</span> <span class="o">=</span> <span class="n">seeker</span> <span class="o">*</span> <span class="n">lover</span>
<span class="nb">print</span><span class="p">(</span> <span class="n">keeper</span> <span class="p">)</span>    
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>8.539539450000001
</pre></div>
</div>
</div>
</div>
<p>From now on, you’ll start seeing <code class="docutils literal notranslate"><span class="pre">#</span></code> characters appearing in the code extracts, with some human-readable explanatory remarks next to them. These are still perfectly legitimate commands, since Python knows that it should ignore the <code class="docutils literal notranslate"><span class="pre">#</span></code> character and everything after it. But hopefully they’ll help make things a little easier to understand.</p>
</div>
<div class="section" id="installing-and-importing">
<span id="packageinstall"></span><h2><span class="section-number">3.2. </span>Installing and importing<a class="headerlink" href="#installing-and-importing" title="Permalink to this headline">¶</a></h2>
<p>There is lots to love about Python as a programming language. Although it has its quirks and peculiarities like any language (programming or natural), it is relatively flexible and welcoming to newcomers, while still be very, very powerful. But one of the best things about Python isn’t even the language itself, it is the rich ecosystem of code written by other people that you can use to make Python do things for you. These <strong>libraries</strong> or <strong>packages</strong> <a class="footnote-reference brackets" href="#note2" id="id2">2</a> contain code that people have written to solve particular problems, and then kindly made available for other people, like you and me, so that we don’t have to spend our time reinventing the wheel. By installing and importing libraries, you can achieve very complicated things with only a few lines of your own code, by standing on the shoulders of others. Just ask Cueball from the webcomic xkcd:<a class="footnote-reference brackets" href="#note3" id="id3">3</a></p>
<p><img alt="xkcdpython" src="https://imgs.xkcd.com/comics/python.png" /></p>
<p>When doing anything other than the very most basic forms of data analysis in Python, we will almost always need to use libraries. However, before we get started, there’s a critical distinction that you need to understand, which is the difference between having a package <strong><em>installed</em></strong> on your computer, and having a package <strong><em>imported</em></strong> in Python. I do not have any idea how many Python libraries are available out there, but it is a lot. Thousands. If you install Python on your computer, you won’t get all of them, just a handfull of the standard ones. Depending on how you install Python on your computer, you may have more or fewer libraries installed, but either way, there are thousands more out there that you do not currently have installed. So that’s what installed means: it means “it’s on your computer somewhere”. The critical thing to remember is that just because something is on your computer doesn’t mean Python can use it. In order for Python to be able to <em>use</em> one of your installed libraries, that library must also be “imported”. Basically what it boils down to is this:</p>
<blockquote>
<div><p>A library must be installed before it can be imported.</p>
</div></blockquote>
<blockquote>
<div><p>A library must be imported before it can be used.</p>
</div></blockquote>
<p>This two step process might seem a little odd at first, but the designers of Python had very good reasons to do it this way,<a class="footnote-reference brackets" href="#note4" id="id4">4</a> and you get the hang of it pretty quickly.</p>
<p>I won’t get into the details of installing libraries here, simply because it is too much for me to tackle. If you are using Python in an online enviroment, you may already have access to all the libraries mentioned in this book. If you are working with Python on your own computer, the exact details of how you install packages may vary. If you want to use Python on your own computer, and are just getting started, I recommend <a class="reference external" href="https://www.anaconda.com/products/individual#Downloads">Anaconda</a> as a relatively easy way to install Python and get quick access to all the most common and important libraries.</p>
<div class="section" id="what-libraries-does-this-book-use">
<h3><span class="section-number">3.2.1. </span>What libraries does this book use?<a class="headerlink" href="#what-libraries-does-this-book-use" title="Permalink to this headline">¶</a></h3>
<p>In this book, I have made a concerted effort to limit the number of libraries needed. Often you will find that you can use different libraries to achieve the same results, and sometimes one of these may suit your needs more than another. This is something that can make doing analysis by code rather than pointing and clicking in a dedicated statistics program a bit off-putting; in Excel, there is usually only way to do things, while in Python, there are many. I think this is part of what makes doing statistics using code better, though: you can make your own informed choices, and do <em>exactly</em> the analysis you want to do; you don’t have to accept some piece of software’s default settings. However, point of this book is to get you started doing data analysis and statistics in Python, not to show you all the different ways you could achieve the same goal, so in an effort to keep things simple, I have tried to limit the libraries used in this book to a few of the most important and most common ones for doing statistics with Python. The most prominent ones are: <code class="docutils literal notranslate"><span class="pre">numpy</span></code>, <code class="docutils literal notranslate"><span class="pre">scipy</span></code>, <code class="docutils literal notranslate"><span class="pre">pandas</span></code>, <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code>, <code class="docutils literal notranslate"><span class="pre">seaborn</span></code>, <code class="docutils literal notranslate"><span class="pre">statistics</span></code>, <code class="docutils literal notranslate"><span class="pre">math</span></code>, and <code class="docutils literal notranslate"><span class="pre">statsmodels</span></code>, but I may use others as well, as needed.</p>
</div>
<div class="section" id="importing-libraries">
<h3><span class="section-number">3.2.2. </span>Importing libraries<a class="headerlink" href="#importing-libraries" title="Permalink to this headline">¶</a></h3>
<p>Assuming you have the libraries you need installed on your computer, or can access them in the virtual Python environment you are using in your browser, you will need to import them before you can actually use them. So, for instance, if I want to find the sum of five numbers, I can write</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="nb">sum</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>18
</pre></div>
</div>
</div>
</div>
<p>because the authors of Python felt that adding numbers together was such a basic thing that there should be a built-in command for it. At least, I assume so. I don’t really know what the authors of Python thought. But, oddly, enough, Python doesn’t have a built-in command called “mean”. So if I want to know the mean of those same five numbers, I cannot just write</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mean</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">NameError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">4</span><span class="o">-</span><span class="n">a21faee3aca1</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="n">mean</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>

<span class="ne">NameError</span>: name &#39;mean&#39; is not defined
</pre></div>
</div>
</div>
</div>
<p>because Python doesn’t know what mean, er, means. Luckily, we don’t have to resort to first finding the sum and then dividing by the number of numbers, because there are libraries that <em>do</em> have built-in commands for finding means. The <code class="docutils literal notranslate"><span class="pre">statistics</span></code> library is one. To use the commands in this library, we first have to <code class="docutils literal notranslate"><span class="pre">import</span></code> it. This gives us access to all the many useful commands in the <code class="docutils literal notranslate"><span class="pre">statistics</span></code> library, one of which is <code class="docutils literal notranslate"><span class="pre">mean</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">statistics</span>

<span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>

<span class="n">statistics</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3.6
</pre></div>
</div>
</div>
</div>
<p>You probably noticed the <code class="docutils literal notranslate"><span class="pre">.</span></code> in the code above. This is the way we tell Python that we want to use a command called <code class="docutils literal notranslate"><span class="pre">mean</span></code> which is found inside the library <code class="docutils literal notranslate"><span class="pre">statistics</span></code>. Without the <code class="docutils literal notranslate"><span class="pre">.</span></code>, even though we have imported <code class="docutils literal notranslate"><span class="pre">statistics</span></code>, which has a command called <code class="docutils literal notranslate"><span class="pre">mean</span></code>, we still can’t just write <code class="docutils literal notranslate"><span class="pre">mean(numbers)</span></code>. We have to tell Python where to look for this command. This all seems very cumbersome, but it’s really not so bad, there are good reasons for doing it this way<a class="footnote-reference brackets" href="#note4" id="id5">4</a>, and you will get used to it fairly quickly.</p>
<p>One of the ways in which Python is quite flexible is that it gives you some options in terms of how you import libraries. More precisely, you can:</p>
<blockquote>
<div><p>Choose to import only a portion of a library
rename libraries of portions of libraries when importing</p>
</div></blockquote>
<p>Let’s say we don’t want to import the entire <code class="docutils literal notranslate"><span class="pre">statistics</span></code> library — we only want the <code class="docutils literal notranslate"><span class="pre">mean</span></code> command. We can achieve this like this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">statistics</span> <span class="kn">import</span> <span class="n">mean</span>
</pre></div>
</div>
</div>
</div>
<p>Why would we want to do this? Well, one good reason is that now we <em>can</em> simply write <code class="docutils literal notranslate"><span class="pre">mean(numbers)</span></code>; we no longer have to write out <code class="docutils literal notranslate"><span class="pre">statistics.mean(numbers</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">mean</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3.6
</pre></div>
</div>
</div>
</div>
<p>Is this the height of laziness? Maybe. But if you start writing the same thing over and over again, saving a few characters here and there is pretty sweet. And this brings us to the other import option: renaming libraries. It is common practice in Python to give libraries abbreviations when we import them. Many of the most common libraries have conventional abbreviations, although you could use anything you like. Thus, you will often see e.g.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
</pre></div>
</div>
</div>
</div>
<p>This is very convenient, but be careful: if you e.g. import <code class="docutils literal notranslate"><span class="pre">numpy</span></code> as <code class="docutils literal notranslate"><span class="pre">np</span></code>, the Python will only recognize it as <code class="docutils literal notranslate"><span class="pre">np</span></code>, at least for the time your code is in Python’s active memory. Also, although you can use whatever abbreviations you like, I highly recommend sticking to the conventional ones, for your sake and others. It’s kind of fun the first time to do something like</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">statistics</span> <span class="k">as</span> <span class="nn">why_you_gotta_be_so</span>

<span class="n">why_you_gotta_be_so</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3.6
</pre></div>
</div>
</div>
</div>
<p>but good code should be easy to read by yourself and others, and if you start playing too fast and loose with renaming, it starts to get less clear what’s going on.</p>
</div>
</div>
<div class="section" id="listing-the-objects-in-active-memory">
<h2><span class="section-number">3.3. </span>Listing the objects in active memory<a class="headerlink" href="#listing-the-objects-in-active-memory" title="Permalink to this headline">¶</a></h2>
<p>Let’s suppose that you’re reading through this book, and what you’re doing is sitting down with it once a week and working through a whole chapter in each sitting. Not only that, you’ve been following my advice and typing in all these commands into Python. So far during this chapter, you’d have typed quite a few commands, although not all of them actually created variables.</p>
<p>An important part of learning to program is to develop the ability to keep a mental model of what Python knows and doesn’t know at any given time active in your mind. This sounds very abstract, and it is, but as you become more familar with coding I think you will see what I mean. I won’t dwell on this here, but it may be useful to take a quick peak at what I mean. If you are working in e.g. a Jupyter Notebook (and I do suggest you do this, at least at first), then by typing <code class="docutils literal notranslate"><span class="pre">%who</span></code> you can see a list of all the variable that Python is currently aware of. So, in my case, I get the following:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">who</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>keeper	 lover	 mean	 mean_numbers	 np	 numbers	 seeker	 sns	 statistics	 
sum_numbers	 why_you_gotta_be_so	 
</pre></div>
</div>
</div>
</div>
<p>Here we can see variable that we defined, like <code class="docutils literal notranslate"><span class="pre">keeper</span></code> and <code class="docutils literal notranslate"><span class="pre">lover</span></code>, and also libraries that we imported (and renamed), like <code class="docutils literal notranslate"><span class="pre">np</span></code> and <code class="docutils literal notranslate"><span class="pre">sns</span></code>, as well as the library <code class="docutils literal notranslate"><span class="pre">statistics</span></code> which I then ill-advisedly re-imported and renamed <code class="docutils literal notranslate"><span class="pre">why_you_gotta_be_so</span></code>. To see more details on these variables, we can type <code class="docutils literal notranslate"><span class="pre">%whos</span></code></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">whos</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Variable              Type        Data/Info
-------------------------------------------
keeper                float       8.539539450000001
lover                 float       2.7183
mean                  function    &lt;function mean at 0x7fd3d2cdfc20&gt;
mean_numbers          float       3.6
np                    module      &lt;module &#39;numpy&#39; from &#39;/op&lt;...&gt;kages/numpy/__init__.py&#39;&gt;
numbers               list        n=5
seeker                float       3.1415
sns                   module      &lt;module &#39;seaborn&#39; from &#39;/&lt;...&gt;ges/seaborn/__init__.py&#39;&gt;
statistics            module      &lt;module &#39;statistics&#39; from&lt;...&gt;python3.7/statistics.py&#39;&gt;
sum_numbers           int         18
why_you_gotta_be_so   module      &lt;module &#39;statistics&#39; from&lt;...&gt;python3.7/statistics.py&#39;&gt;
</pre></div>
</div>
</div>
</div>
<p>This tells us that e.g. <code class="docutils literal notranslate"><span class="pre">keeper</span></code> is a floating-point decimal number with the value 8.539539450000001, and shows us the true names of the objects we have renamed on import. These commands that start with a <code class="docutils literal notranslate"><span class="pre">%</span></code> sign, by the way, are called “magic” commands, and can only be used in environments like Jupyter, which support them. If you are not working in such an environment, you can use the command <code class="docutils literal notranslate"><span class="pre">dir()</span></code>, which achieve the same thing, but will also show you lots of information you probably aren’t interested in at this stage.</p>
<div class="section" id="removing-variables-from-the-workspace">
<h3><span class="section-number">3.3.1. </span>Removing variables from the workspace<a class="headerlink" href="#removing-variables-from-the-workspace" title="Permalink to this headline">¶</a></h3>
<p>Looking over that list of variables, it occurs to me that I really don’t need them any more. I created them originally just to make a point, but they don’t serve any useful purpose anymore, and now I want to get rid of them.  I’ll show you how to do this, but first I want to warn you – there’s no “undo” option for variable removal. Once a variable is removed, it’s gone forever unless you save it to disk. I’ll show you how to do <em>that</em> in a later section, but quite clearly we have no need for these variables at all, so we can safely get rid of them by using the <code class="docutils literal notranslate"><span class="pre">del()</span></code> command.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">del</span><span class="p">(</span><span class="n">keeper</span><span class="p">,</span> <span class="n">lover</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>With <code class="docutils literal notranslate"><span class="pre">%who</span></code> or <code class="docutils literal notranslate"><span class="pre">dir()</span></code> we can check that they are gone.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">who</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>mean	 mean_numbers	 np	 numbers	 seeker	 sns	 statistics	 sum_numbers	 why_you_gotta_be_so	 
</pre></div>
</div>
</div>
</div>
<p>If you want to remove all the variables in memory, and you are working in a Jupyter environment, then <code class="docutils literal notranslate"><span class="pre">%reset</span></code> is a handy way to do this, although I must say that in practice I rarely if ever have a need to remove variables from memory. There is usually no harm in them sitting around unused, and if you define a new variable with the same name as an old one, it will just write over the old variable with the same name.</p>
</div>
</div>
<div class="section" id="loading-and-saving-data">
<span id="load"></span><h2><span class="section-number">3.4. </span>Loading and saving data<a class="headerlink" href="#loading-and-saving-data" title="Permalink to this headline">¶</a></h2>
<p>There are two main types of files that are likely to be relevant to us when doing data analysis. There are three in particular that are especially important from the perspective of this book:</p>
<ul class="simple">
<li><p><em>Comma separated value (CSV) files</em> are those with a .csv file extension. These are just regular old text files, and they can be opened with almost any software. It’s quite typical for people to store data in CSV files, precisely because they’re so simple.</p></li>
<li><p><em>Script files</em> are those with a .py file extension or an .ipynb extension. These aren’t data files at all; rather, they’re used to save a collection of commands that you want Python to execute later. They’re just text files, but we won’t make use of them until later.</p></li>
</ul>
<p>In this section I’ll talk about how to import data from a CSV file, and how to save your workspace to a workspace file. Throughout this section I’ll first describe the (sometimes awkward) R commands that do all the work, and then I’ll show you the (much easier) way to do it using RStudio.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>### Loading workspace files using R

When I used the `list.files()` command to list the contents of the `/Users/dan/Rbook/data` directory (in Section \@ref(navigationR)), the output referred to a file called booksales.Rdata. Let&#39;s say I want to load the data from this file into my workspace. The way I do this is with the `load()` function. There are two arguments to this function, but the only one we&#39;re interested in is

- `file`. This should be a character string that specifies a path to the file that needs to be loaded. You can use an absolute path or a relative path to do so.

Using the absolute file path, the command would look like this:
```
load( file = &quot;/Users/dan/Rbook/data/booksales.Rdata&quot; )
```
but this is pretty lengthy. Given that the working directory (remember, we changed the directory at the end of Section \@ref(nav3)) is `/Users/dan/Rbook/data`, I could use a relative file path, like so:
```
load( file = &quot;../data/booksales.Rdata&quot; )
```
However, my preference is usually to change the working directory first, and *then* load the file. What that would look like is this:
```
setwd( &quot;../data&quot; )         # move to the data directory
load( &quot;booksales.Rdata&quot; )  # load the data
```
If I were then to type `who()` I&#39;d see that there are several new variables in my workspace now.  Throughout this book, whenever you see me loading a file, I will assume that the file is actually stored in the working directory, or that you&#39;ve changed the working directory so that R is pointing at the directory that contains the file. Obviously, *you* don&#39;t need type that command yourself: you can use the RStudio file panel to do the work.

### Loading workspace files using RStudio

Okay, so how do we open an .Rdata file using the RStudio file panel? It&#39;s terribly simple. First, use the file panel to find the folder that contains the file you want to load. If you look at Figure \@ref(fig:filepanel), you can see that there are several .Rdata files listed. Let&#39;s say I want to load the `booksales.Rdata` file. All I have to do is click on the file name. RStudio brings up a little dialog box asking me to confirm that I do want to load this file. I click yes. The following command then turns up in the console,
```
load(&quot;~/Rbook/data/booksales.Rdata&quot;)
```
and the new variables will appear in the workspace (you&#39;ll see them in the Environment panel in RStudio, or if you type `who()`). So easy it barely warrants having its own section.


### Importing data from CSV files using loadingcsv{#loadingcsv}

One quite commonly used data format is the humble &quot;comma separated value&quot; file, also called a CSV file, and usually bearing the file extension .csv. CSV files are just plain old-fashioned text files, and what they store is basically just a table of data. This is illustrated in Figure \@ref(fig:booksalescsv), which shows a file called booksales.csv that I&#39;ve created. As you can see, each row corresponds to a variable, and each row represents the book sales data for one month. The first row doesn&#39;t contain actual data though: it has the names of the variables.

```{r booksalescsv, fig.cap=&quot;The booksales.csv data file. On the left, I&#39;ve opened the file in using a spreadsheet program (OpenOffice), which shows that the file is basically a table. On the right, the same file is open in a standard text editor (the TextEdit program on a Mac), which shows how the file is formatted. The entries in the table are wrapped in quote marks and separated by commas.&quot;, echo=FALSE}

knitr::include_graphics(here::here(&quot;bookdown&quot;, &quot;img&quot;, &quot;mechanics&quot;, &quot;booksalescsv.jpg&quot;))

```

If RStudio were not available to you, the easiest way to open this file would be to use the `read.csv()` function.^[In a lot of books you&#39;ll see the `read.table()` function used for this purpose instead of `read.csv()`. They&#39;re more or less identical functions, with the same arguments and everything. They differ only in the default values.] This function is pretty flexible, and I&#39;ll talk a lot more about it&#39;s capabilities in Section \@ref(importing) for more details, but for now there&#39;s only two arguments to the function that I&#39;ll mention:

- `file`. This should be a character string that specifies a path to the file that needs to be loaded. You can use an absolute path or a relative path to do so.
- `header`. This is a logical value indicating whether or not the first row of the file contains variable names. The default value is `TRUE`. 

Therefore, to import the CSV file, the command I need is:

```{r echo=FALSE}
books &lt;- read.csv( file = &quot;./data/booksales.csv&quot; )
```

```{r eval=FALSE}
books &lt;- read.csv( file = &quot;booksales.csv&quot; )
```
There are two very important points to notice here. Firstly, notice that I *didn&#39;t* try to use the `load()` function, because that function is only meant to be used for .Rdata files. If you try to use `load()` on other types of data, you get an error. Secondly, notice that when I imported the CSV file I assigned the result to a variable, which I imaginatively called `books`.^[Note that I didn&#39;t to this in my earlier example when loading the .Rdata] file. There&#39;s a reason for this. The idea behind an `.Rdata` file is that it stores a whole workspace. So, if you had the ability to look inside the file yourself you&#39;d see that the data file keeps track of all the variables and their names. So when you `load()` the file, R restores all those original names. CSV files are treated differently: as far as R is concerned, the CSV only stores *one* variable, but that variable is big table. So when you import that table into the workspace, R expects *you* to give it a name.] Let&#39;s have a look at what we&#39;ve got:
```{r}
print( books )
```
Clearly, it&#39;s worked, but the format of this output is a bit unfamiliar. We haven&#39;t seen anything like this before. What you&#39;re looking at is a *data frame*, which is a very important kind of variable in R, and one I&#39;ll discuss in Section \@ref(dataframes). For now, let&#39;s just be happy that we imported the data and that it looks about right.


### Importing data from CSV files using RStudio

Yet again, it&#39;s easier in RStudio. In the environment panel in RStudio you should see a button called &quot;Import Dataset&quot;. Click on that, and it will give you a couple of options: select the &quot;From Text File...&quot; option, and it will open up a very familiar dialog box asking you to select a file: if you&#39;re on a Mac, it&#39;ll look like the usual Finder window that you use to choose a file; on Windows it looks like an Explorer window. An example of what it looks like on a Mac is shown in Figure \@ref(fig:fileopen). I&#39;m assuming that you&#39;re familiar with your own computer, so you should have no problem finding the CSV file that you want to import! Find the one you want, then click on the &quot;Open&quot; button. When you do this, you&#39;ll see a window that looks like the one in Figure \@ref(fig:import).

```{r fileopen, fig.cap=&quot;A dialog box on a Mac asking you to select the CSV file R should try to import. Mac users will recognise this immediately: it&#39;s the usual way in which a Mac asks you to find a file. Windows users won&#39;t see this: they&#39;ll see the usual explorer window that Windows always gives you when it wants you to select a file.&quot;, echo=FALSE}

knitr::include_graphics(here::here(&quot;bookdown&quot;, &quot;img&quot;, &quot;mechanics&quot;, &quot;openscreen.png&quot;))

```





The import data set window is relatively straightforward to understand. 

```{r import, fig.cap=&quot;The RStudio window for importing a CSV file into R&quot;, echo=FALSE}

knitr::include_graphics(here::here(&quot;bookdown&quot;, &quot;img&quot;, &quot;mechanics&quot;, &quot;import.png&quot;))

```

In the top left corner, you need to type the name of the variable you R to create. By default, that will be the same as the file name: our file is called `booksales.csv`, so RStudio suggests the name `booksales`. If you&#39;re happy with that, leave it alone. If not, type something else. Immediately below this are a few things that you can tweak to make sure that the data gets imported correctly: 


- Heading. Does the first row of the file contain raw data, or does it contain headings for each variable? The `booksales.csv` file has a header at the top, so I selected &quot;yes&quot;.
- Separator. What character is used to separate different entries? In most CSV files this will be a comma (it is &quot;comma separated&quot; after all). But you can change this if your file is different. 
- Decimal. What character is used to specify the decimal point? In English speaking countries, this is almost always a period (i.e., `.`). That&#39;s not universally true: many European countries use a comma. So you can change that if you need to.
- Quote. What character is used to denote a block of text? That&#39;s usually going to be a double quote mark. It is for the `booksales.csv` file, so that&#39;s what I selected.

The nice thing about the RStudio window is that it shows you the raw data file at the top of the window, and it shows you a preview of the data at the bottom. If the data at the bottom doesn&#39;t look right, try changing some of the settings on the left hand side. Once you&#39;re happy, click &quot;Import&quot;. When you do, two commands appear in the R console:
```
booksales &lt;- read.csv(&quot;~/Rbook/data/booksales.csv&quot;)
View(booksales)
```
The first of these commands is the one that loads the data. The second one will display a pretty table showing the data in RStudio. 


### Saving a workspace file using `save`

Not surprisingly, saving data is very similar to loading data. Although RStudio provides a simple way to save files (see below), it&#39;s worth understanding the actual commands involved. There are two commands you can use to do this, `save()` and `save.image()`. If you&#39;re happy to save *all* of the variables in your workspace into the data file, then you should use `save.image()`. And if you&#39;re happy for R to save the file into the current working directory, all you have to do is this:
```{r eval=FALSE}
save.image( file = &quot;myfile.Rdata&quot; )
```
Since `file` is the first argument, you can shorten this to `save.image(&quot;myfile.Rdata&quot;)`; and if you want to save to a different directory, then (as always) you need to be more explicit about specifying the path to the file, just as we discussed in Section \@ref(navigation). Suppose, however, I have several variables in my workspace, and I only want to save some of them. For instance, I might have this as my workspace:
```{r eval=FALSE}
who()
##   -- Name --   -- Class --   -- Size --
##   data         data.frame    3 x 2     
##   handy        character     1         
##   junk         numeric       1        
```
I want to save `data` and `handy`, but not `junk`. But I don&#39;t want to delete `junk` right now, because I want to use it for something else later on. This is where the `save()` function is useful, since it lets me indicate exactly which variables I want to save. Here is one way I can use the `save` function to solve my problem:
```{r eval=FALSE}
save(data, handy, file = &quot;myfile.Rdata&quot;)
```
Importantly, you *must* specify the name of the `file` argument. The reason is that if you don&#39;t do so, R will think that `&quot;myfile.Rdata&quot;` is actually a *variable* that you want to save, and you&#39;ll get an error message. Finally, I should mention a second way to specify which variables the `save()` function should save, which is to use the `list` argument. You do so like this:
```{r eval = FALSE}
save.me &lt;- c(&quot;data&quot;, &quot;handy&quot;)   # the variables to be saved
save( file = &quot;booksales2.Rdata&quot;, list = save.me )   # the command to save them
```

### Saving a workspace file using RStudio{#save1}

RStudio allows you to save the workspace pretty easily. In the environment panel (Figures \@ref(fig:workspace) and \@ref(fig:workspace2)) you can see the &quot;save&quot; button. There&#39;s no text, but it&#39;s the same icon that gets used on every computer everywhere: it&#39;s the one that looks like a floppy disk. You know, those things that haven&#39;t been used in about 20 years. Alternatively, go to the &quot;Session&quot; menu and click on the &quot;Save Workspace As...&quot; option.^[A word of warning: what you *don&#39;t* want to do is use the &quot;File&quot; menu. If you look in the &quot;File&quot; menu you will see &quot;Save&quot; and &quot;Save As...&quot; options, but they don&#39;t save the workspace. Those options are used for dealing with *scripts*, and so they&#39;ll produce `.R` files. We won&#39;t get to those until Chapter \@ref(scripting).] This will bring up the standard &quot;save&quot; dialog box for your operating system (e.g., on a Mac it&#39;ll look a little bit like the loading dialog box in Figure \@ref(fig:fileopen)). Type in the name of the file that you want to save it to, and all the variables in your workspace will be saved to disk. You&#39;ll see an R command like this one
```{r eval=FALSE}
save.image(&quot;~/Desktop/Untitled.RData&quot;)
```
Pretty straightforward, really.



### Other things you might want to save

Until now, we&#39;ve talked mostly about loading and saving *data*. Other things you might want to save include:



- *The output*. Sometimes you might also want to keep a copy of all your interactions with R, including everything that you typed in and everything that R did in response. There are some functions that you can use to get R to write its output to a file rather than to print onscreen (e.g., `sink()`), but to be honest, if you do want to save the R output, the easiest thing to do is to use the mouse to select the relevant text in the R console, go to the &quot;Edit&quot; menu in RStudio and select &quot;Copy&quot;. The output has now been copied to the clipboard. Now open up your favourite text editor or word processing software, and paste it. And you&#39;re done.  However, this will only save the contents of the console, not the plots you&#39;ve drawn (assuming you&#39;ve drawn some). We&#39;ll talk about saving images later on.


- *A script*. While it is possible -- and sometimes handy -- to save the R output as a method for keeping a copy of your statistical analyses, another option that people use a lot (especially when you move beyond simple &quot;toy&quot; analyses) is to write *scripts*. A script is a text file in which you write out all the commands that you want R to run. You can write your script using whatever software you like. In real world data analysis writing scripts is a key skill -- and as you become familiar with R you&#39;ll probably find that most of what you do involves scripting rather than typing commands at the R prompt. However, you won&#39;t need to do much scripting initially, so we&#39;ll leave that until Chapter \@ref(scripting).






## Useful things to know about variables{#useful}

In Chapter \@ref(introR) I talked a lot about variables, how they&#39;re assigned and some of the things you can do with them, but there&#39;s a lot of additional complexities. That&#39;s not a surprise of course. However, some of those issues are worth drawing your attention to now. So that&#39;s the goal of this section; to cover a few extra topics. As a consequence, this section is basically a bunch of things that I want to briefly mention, but don&#39;t really fit in anywhere else. In short, I&#39;ll talk about several different issues in this section, which are only loosely connected to one another.



### Special values{#specials}

The first thing I want to mention are some of the &quot;special&quot; values that you might see R produce. Most likely you&#39;ll see them in situations where you were expecting a number, but there are quite a few other ways you can encounter them. These values are `Inf`, `NaN`, `NA` and `NULL`. These values can crop up in various different places, and so it&#39;s important to understand what they mean. 


- *Infinity* (`Inf`). The easiest of the special values to explain is `Inf`, since it corresponds to a value that is infinitely large. You can also have `-Inf`. The easiest way to get `Inf` is to divide a positive number by 0:
```{r}
1 / 0
```
In most real world data analysis situations, if you&#39;re ending up with infinite numbers in your data, then something has gone awry. Hopefully you&#39;ll never have to see them.


- *Not a Number* (`NaN`). The special value of `NaN` is short for &quot;not a number&quot;, and it&#39;s basically a reserved keyword that means &quot;there isn&#39;t a mathematically defined number for this&quot;. If you can remember your high school maths, remember that it is conventional to say that $0/0$ doesn&#39;t have a proper answer: mathematicians would say that $0/0$ is *undefined*. R says that it&#39;s not a number:
```{r}
 0 / 0
```
Nevertheless, it&#39;s still treated as a &quot;numeric&quot; value. To oversimplify, `NaN` corresponds to cases where you asked a proper numerical question that genuinely has *no meaningful answer*. 

- *Not available* (`NA`). 
`NA` indicates that the value that is &quot;supposed&quot; to be stored here is missing. To understand what this means, it helps to recognise that the `NA` value is something that you&#39;re most likely to see when analysing data from real world experiments. Sometimes you get equipment failures, or you lose some of the data, or whatever. The point is that some of the information that you were &quot;expecting&quot; to get from your study is just plain missing. Note the difference between `NA` and `NaN`. For `NaN`, we really do know what&#39;s supposed to be stored; it&#39;s just that it happens to correspond to something like $0/0$ that doesn&#39;t make any sense at all. In contrast, `NA` indicates that we actually don&#39;t know what was supposed to be there. The information is *missing*.

- *No value* (`NULL`).
The `NULL` value takes this &quot;absence&quot; concept even further. It basically asserts that the variable genuinely has no value whatsoever. This is quite different to both `NaN` and `NA`. For `NaN` we actually know what the value is, because it&#39;s something insane like $0/0$. For `NA`, we believe that there is supposed to be a value &quot;out there&quot;, but a dog ate our homework and so we don&#39;t quite know what it is. But for `NULL` we strongly believe that there is *no value at all*.  


### Assigning names to vector elements{#names}

One thing that is sometimes a little unsatisfying about the way that R prints out a vector is that the elements come out unlabelled. Here&#39;s what I mean. Suppose I&#39;ve got data reporting the quarterly profits for some company. If I just create a no-frills vector, I have to rely on memory to know which element corresponds to which event. That is:
```{r}
profit &lt;- c( 3.1, 0.1, -1.4, 1.1 )
profit

```
You can probably guess that the first element corresponds to the first quarter, the second element to the second quarter, and so on, but that&#39;s only because I&#39;ve told you the back story and because this happens to be a very simple example. In general, it can be quite difficult. This is where it can be helpful to assign `names` to each of the elements. Here&#39;s how you do it:
```{r}
names(profit) &lt;- c(&quot;Q1&quot;,&quot;Q2&quot;,&quot;Q3&quot;,&quot;Q4&quot;)
profit
```
This is a slightly odd looking command, admittedly, but it&#39;s not too difficult to follow. All we&#39;re doing is assigning a vector of labels (character strings) to `names(profit)`. You can always delete the names again by using the command `names(profit) &lt;- NULL`. It&#39;s also worth noting that you don&#39;t have to do this as a two stage process. You can get the same result with this command:
```{r}
profit &lt;- c( &quot;Q1&quot; = 3.1, &quot;Q2&quot; = 0.1, &quot;Q3&quot; = -1.4, &quot;Q4&quot; = 1.1 )
profit
```
The important things to notice are that (a) this does make things much easier to read, but (b) the names at the top aren&#39;t the &quot;real&quot; data. The *value* of `profit[1]` is still `3.1`; all I&#39;ve done is added a *name* to `profit[1]` as well. Nevertheless, names aren&#39;t purely cosmetic, since R allows you to pull out particular elements of the vector by referring to their names:
```{r}
profit[&quot;Q1&quot;]
```
And if I ever need to pull out the names themselves, then I just type `names(profit)`. 

### Variable classes

As we&#39;ve seen, R allows you to store different kinds of data. In particular, the variables we&#39;ve defined so far have either been character data (text), numeric data, or logical data.^[Or functions. But let&#39;s ignore functions for the moment.] It&#39;s important that we remember what kind of information each variable stores (and even more important that R remembers) since different kinds of variables allow you to do different things to them. For instance, if your variables have numerical information in them, then it&#39;s okay to multiply them together:
```{r}
x &lt;- 5   # x is numeric
y &lt;- 4   # y is numeric
x * y    
```
But if they contain character data, multiplication makes no sense whatsoever, and R will complain if you try to do it:
```{r error=TRUE}
x &lt;- &quot;apples&quot;   # x is character
y &lt;- &quot;oranges&quot;  # y is character
x * y           
```
Even R is smart enough to know you can&#39;t multiply `&quot;apples&quot;` by `&quot;oranges&quot;`. It knows this because the quote marks are indicators that the variable is supposed to be treated as text, not as a number. 

This is quite useful, but notice that it means that R makes a big distinction between `5` and `&quot;5&quot;`. Without quote marks, R treats `5` as the number five, and will allow you to do calculations with it. With the quote marks, R treats `&quot;5&quot;` as the textual character five, and doesn&#39;t recognise it as a number any more than it recognises `&quot;p&quot;` or `&quot;five&quot;` as numbers.  As a consequence, there&#39;s a big difference between typing `x &lt;- 5` and typing `x &lt;- &quot;5&quot;`. In the former, we&#39;re storing the number `5`; in the latter, we&#39;re storing the character `&quot;5&quot;`. Thus, if we try to do multiplication with the character versions, R gets stroppy:
```{r error=TRUE}
x &lt;- &quot;5&quot;   # x is character
y &lt;- &quot;4&quot;   # y is character
x * y     

```

Okay, let&#39;s suppose that I&#39;ve forgotten what kind of data I stored in the variable `x` (which happens depressingly often). R provides a function that will let us find out. Or, more precisely, it provides *three* functions: `class()`, `mode()` and `typeof()`. Why the heck does it provide three functions, you might be wondering? Basically, because R actually keeps track of three different kinds of information about a variable:

1. The **_class_** of a variable is a &quot;high level&quot; classification, and it captures psychologically (or statistically) meaningful distinctions. For instance `&quot;2011-09-12&quot;` and `&quot;my birthday&quot;` are both text strings, but there&#39;s an important difference between the two: one of them is a date. So it would be nice if we could get R to recognise that `&quot;2011-09-12&quot;` is a date, and allow us to do things like add or subtract from it. The class of a variable is what R uses to keep track of things like that. Because the class of a variable is critical for determining what R can or can&#39;t do with it, the `class()` function is very handy.
2. The **_mode_** of a variable refers to the format of the information that the variable stores. It tells you whether R has stored text data or numeric data, for instance, which is kind of useful, but it only makes these &quot;simple&quot; distinctions. It can be useful to know about, but it&#39;s not the main thing we care about. So I&#39;m not going to use the `mode()` function very much.^[Actually, I don&#39;t think I *ever* use this in practice. I don&#39;t know why I bother to talk about it in the book anymore.] 
3. The **_type_** of a variable is a very low level classification. We won&#39;t use it in this book, but (for those of you that care about these details) this is where you can see the distinction between integer data, double precision numeric, etc. Almost none of you actually will care about this, so I&#39;m not even going to bother demonstrating the `typeof()` function.



For purposes, it&#39;s the `class()` of the variable that we care most about. Later on, I&#39;ll talk a bit about how you can convince R to &quot;coerce&quot; a variable to change from one class to another (Section \@ref(coercion)). That&#39;s a useful skill for real world data analysis, but it&#39;s not something that we need right now. In the meantime, the following examples illustrate the use of the `class()` function:
```{r}
x &lt;- &quot;hello world&quot;     # x is text
class(x)


x &lt;- TRUE     # x is logical 
class(x)

x &lt;- 100     # x is a number
class(x)
```
Exciting, no?





## Factors{#factors}


Okay, it&#39;s time to start introducing some of the data types that are somewhat more specific to statistics. If you remember back to Chapter \@ref(studydesign), when we assign numbers to possible outcomes, these numbers can mean quite different things depending on what kind of variable we are attempting to measure. In particular, we commonly make the distinction between *nominal*, *ordinal*, *interval* and *ratio* scale data. How do we capture this distinction in R? Currently, we only seem to have a single numeric data type. That&#39;s probably not going to be enough, is it?

A little thought suggests that the numeric variable class in R is perfectly suited for capturing ratio scale data. For instance, if I were to measure response time (RT) for five different events, I could store the data in R like this:
```{r}
RT &lt;- c(342, 401, 590, 391, 554)
```
where the data here are measured in milliseconds, as is conventional in the psychological literature. It&#39;s perfectly sensible to talk about &quot;twice the response time&quot;, $2 \times \mbox{RT}$, or the &quot;response time plus 1 second&quot;, $\mbox{RT} + 1000$, and so both of the following are perfectly reasonable things for R to do:
```{r}
2 * RT

RT + 1000
``` 
And to a lesser extent, the &quot;numeric&quot; class is okay for interval scale data, as long as we remember that multiplication and division aren&#39;t terribly interesting for these sorts of variables. That is, if my IQ score is 110 and yours is 120, it&#39;s perfectly okay to say that you&#39;re 10 IQ points smarter than me^[Taking all the usual caveats that attach to IQ measurement as a given, of course.], but it&#39;s not okay to say that I&#39;m only 92% as smart as you are, because intelligence doesn&#39;t have a natural zero.^[Or, more precisely, we don&#39;t know how to measure it. Arguably, a rock has zero intelligence. But it doesn&#39;t make sense to say that the IQ of a rock is 0 in the same way that we can say that the average human has an IQ of 100. And without knowing what the IQ value is that corresponds to a literal absence of any capacity to think, reason or learn, then we really can&#39;t multiply or divide IQ scores and expect a meaningful answer.] We might even be willing to tolerate the use of numeric variables to represent ordinal scale variables, such as those that you typically get when you ask people to rank order items (e.g., like we do in Australian elections), though as we will see R actually has a built in tool for representing ordinal data (see Section \@ref(orderedfactors)) However, when it comes to nominal scale data, it becomes completely unacceptable, because almost all of the &quot;usual&quot; rules for what you&#39;re allowed to do with numbers don&#39;t apply to nominal scale data. It is for this reason that R has **_factors_**. 



### Introducing factors

Suppose, I was doing a study in which people could belong to one of three different treatment conditions. Each group of people were asked to complete the same task, but each group received different instructions. Not surprisingly, I might want to have a variable that keeps track of what group people were in. So I could type in something like this
```{r}
group &lt;- c(1,1,1,2,2,2,3,3,3)
```
so that `group[i]` contains the group membership of the `i`-th person in my study. Clearly, this is numeric data, but equally obviously this is a nominal scale variable. There&#39;s no sense in which &quot;group 1&quot; plus &quot;group 2&quot; equals &quot;group 3&quot;, but nevertheless if I try to do that, R won&#39;t stop me because it doesn&#39;t know any better:
```{r}
group + 2
```
Apparently R seems to think that it&#39;s allowed to invent &quot;group 4&quot; and &quot;group 5&quot;, even though they didn&#39;t actually exist. Unfortunately, R is too stupid to know any better: it thinks that `3` is an ordinary number in this context, so it sees no problem in calculating `3 + 2`. But since *we&#39;re* not that stupid, we&#39;d like to stop R from doing this. We can do so by instructing R to treat `group` as a factor.  This is easy to do using the `as.factor()` function.^[Once again, this is an example of *coercing* a variable from one class to another. I&#39;ll talk about coercion in more detail in Section \@ref(coercion).] 
```{r}
group &lt;- as.factor(group)
group

```
It looks more or less the same as before (though it&#39;s not immediately obvious what all that `Levels` rubbish is about), but if we ask R to tell us what the class of the `group` variable is now, it&#39;s clear that it has done what we asked:
```{R}
class(group)

```
Neat. Better yet, now that I&#39;ve converted `group` to a factor, look what happens when I try to add 2 to it:
```{r}
group + 2

```
This time even R is smart enough to know that I&#39;m being an idiot, so it tells me off and then produces a vector of missing values. (i.e., `NA`: see Section \@ref(specials)).


### Labelling the factor levels

I have a confession to make. My memory is not infinite in capacity; and it seems to be getting worse as I get older. So it kind of annoys me when I get data sets where there&#39;s a nominal scale variable called `gender`, with two levels corresponding to males and females. But when I go to print out the variable I get something like this:
```{r echo=FALSE}
gender&lt;-as.factor(c(1, 1 ,1, 1 ,1, 2 ,2, 2 , 2))
```


```{r}
gender

```
Okaaaay. That&#39;s not helpful at all, and it makes me very sad. Which number corresponds to the males and which one corresponds to the females? Wouldn&#39;t it be nice if R could actually keep track of this? It&#39;s way too hard to remember which number corresponds to which gender. To fix this problem what we need to do is assign meaningful labels to the different *levels* of each factor. We can do that like this:
```{r}
levels(group) &lt;- c(&quot;group 1&quot;, &quot;group 2&quot;, &quot;group 3&quot;)
print(group)

levels(gender) &lt;- c(&quot;male&quot;, &quot;female&quot;)
print(gender)
```
That&#39;s much easier on the eye.


### Moving on...

Factors are very useful things, and we&#39;ll use them a lot in this book: they&#39;re *the* main way to represent a nominal scale variable. And there are lots of nominal scale variables out there. I&#39;ll talk more about factors in Section \@ref(orderedfactors), but for now you know enough to be able to get started.




## Data frames{#dataframes}

It&#39;s now time to go back and deal with the somewhat confusing thing that happened in Section \@ref(loadingcsv) when we tried to open up a CSV file. Apparently we succeeded in loading the data, but it came to us in a very odd looking format. At the time, I told you that this was a **_data frame_**. Now I&#39;d better explain what that means.



### Introducing data frames

```{r echo=FALSE}
rm(books, keeper, profit, RT, x, y)
```


In order to understand why R has created this funny thing called a data frame, it helps to try to see what problem it solves. So let&#39;s go back to the little scenario that I used when introducing factors in Section \@ref(factors). In that section I recorded the `group` and `gender` for all 9 participants in my study. Let&#39;s also suppose I recorded their ages and their `score` on &quot;Dan&#39;s Terribly Exciting Psychological Test&quot;:
```{r}
age &lt;- c(17, 19, 21, 37, 18, 19, 47, 18, 19)
score &lt;- c(12, 10, 11, 15, 16, 14, 25, 21, 29)
```
Assuming no other variables are in the workspace, if I type `who()` I get this:
```{r}
who()
```
So there are four variables in the workspace, `age`, `gender`, `group` and `score`. And it just so happens that all four of them are the same size (i.e., they&#39;re all vectors with 9 elements). Aaaand it just so happens that `age[1]` corresponds to the age of the first person, and `gender[1]` is the gender of that very same person, etc. In other words, you and I both know that all four of these variables correspond to the *same* data set, and all four of them are organised in exactly the same way. 

However, R *doesn&#39;t* know this! As far as it&#39;s concerned, there&#39;s no reason why the `age` variable has to be the same length as the `gender` variable; and there&#39;s no particular reason to think that `age[1]` has any special relationship to `gender[1]` any more than it has a special relationship to `gender[4]`. In other words, when we store everything in separate variables like this, R doesn&#39;t know anything about the relationships between things. It doesn&#39;t even really know that these variables actually refer to a proper data set. The data frame fixes this: if we store our variables inside a data frame, we&#39;re telling R to treat these variables as a single, fairly coherent data set. 

To see how they do this, let&#39;s create one. So how do we create a data frame? One way we&#39;ve already seen: if we import our data from a CSV file, R will store it as a data frame. A second way is to create it directly from some existing variables using the `data.frame()` function. All you have to do is type a list of variables that you want to include in the data frame. The output of a `data.frame()` command is, well, a data frame. So, if I want to store all four variables from my experiment in a data frame called `expt` I can do so like this:
```{r}
expt &lt;- data.frame ( age, gender, group, score ) 
expt 
```
Note that `expt` is a completely self-contained variable. Once you&#39;ve created it, it no longer depends on the original variables from which it was constructed. That is, if we make changes to the original `age` variable, it will *not* lead to any changes to the age data stored in `expt`. 



### Pulling out the contents of the data frame using `$`

```{r echo=FALSE}
rm(age, gender, group, score)
```


At this point, our workspace contains only the one variable, a data frame called `expt`. But as we can see when we told R to print the variable out, this data frame contains 4 variables, each of which has 9 observations. So how do we get this information out again? After all, there&#39;s no point in storing information if you don&#39;t use it, and there&#39;s no way to use information if you can&#39;t access it. So let&#39;s talk a bit about how to pull information out of a data frame. 

The first thing we might want to do is pull out one of our stored variables, let&#39;s say `score`. One thing you might try to do is ignore the fact that `score` is locked up inside the `expt` data frame. For instance, you might try to print it out like this:
```{r error=TRUE}
score
```
This doesn&#39;t work, because R doesn&#39;t go &quot;peeking&quot; inside the data frame unless you explicitly tell it to do so. There&#39;s actually a very good reason for this, which I&#39;ll explain in a moment, but for now let&#39;s just assume R knows what it&#39;s doing. How do we tell R to look inside the data frame? As is always the case with R there are several ways. The simplest way is to use the `$` operator to extract the variable you&#39;re interested in, like this:
```{r}
expt$score
```



### Getting information about a data frame

One problem that sometimes comes up in practice is that you forget what you called all your variables. Normally you might try to type `objects()` or `who()`, but neither of those commands will tell you what the names are for those variables inside a data frame! One way is to ask R to tell you what the *names* of all the variables stored in the data frame are, which you can do using the `names()` function:
```{r}
names(expt)
```
An alternative method is to use the `who()` function, as long as you tell it to look at the variables inside data frames. If you set `expand = TRUE` then it will not only list the variables in the workspace, but it will &quot;expand&quot; any data frames that you&#39;ve got in the workspace, so that you can see what they look like. That is:
```{r}
who(expand = TRUE)
```
or, since `expand` is the first argument in the `who()` function you can just type `who(TRUE)`. I&#39;ll do that a lot in this book.


### Looking for more on data frames?

There&#39;s a lot more that can be said about data frames: they&#39;re fairly complicated beasts, and the longer you use R the more important it is to make sure you really understand them. We&#39;ll talk a lot more about them in Chapter \@ref(datahandling).







## Lists{#lists}

The next kind of data I want to mention are **_lists_**. Lists are an extremely fundamental data structure in R, and as you start making the transition from a novice to a savvy R user you will use lists all the time. I don&#39;t use lists very often in this book -- not directly -- but most of the advanced data structures in R are built from lists (e.g., data frames are actually a specific type of list). Because lists are so important to how R stores things, it&#39;s useful to have a basic understanding of them. Okay, so what is a list, exactly? Like data frames, lists are just &quot;collections of variables.&quot; However, unlike data frames -- which are basically supposed to look like a nice &quot;rectangular&quot; table of data -- there are no constraints on what kinds of variables we include, and no requirement that the variables have any particular relationship to one another. In order to understand what this actually *means*, the best thing to do is create a list, which we can do using the `list()` function. If I type this as my command:
```{r}
Dan &lt;- list( age = 34,
            nerd = TRUE,
            parents = c(&quot;Joe&quot;,&quot;Liz&quot;) 
)
```
R creates a new list variable called `Dan`, which is a bundle of three different variables: `age`, `nerd` and `parents`. Notice, that the `parents` variable is longer than the others. This is perfectly acceptable for a list, but it wouldn&#39;t be for a data frame. If we now print out the variable, you can see the way that R stores the list:
```{r}
print( Dan )
```
As you might have guessed from those `$` symbols everywhere, the variables are stored in exactly the same way that they are for a data frame (again, this is not surprising: data frames *are* a type of list). So you will (I hope) be entirely unsurprised and probably quite bored when I tell you that you can extract the variables from the list using the `$` operator, like so:
```{r}
Dan$nerd
```
If you need to add new entries to the list, the easiest way to do so is to again use `$`, as the following example illustrates. If I type a command like this
```{r}
Dan$children &lt;- &quot;Alex&quot;
```
then R creates a new entry to the end of the list called `children`, and assigns it a value of `&quot;Alex&quot;`. If I were now to `print()` this list out, you&#39;d see a new entry at the bottom of the printout. Finally, it&#39;s actually possible for lists to contain other lists, so it&#39;s quite possible that I would end up using a command like `Dan$children$age` to find out how old my son is. Or I could try to remember it myself I suppose. 




## Formulas{#formulas}
 
The last kind of variable that I want to introduce before finally being able to start talking about statistics is the **_formula_**. Formulas were originally introduced into R as a convenient way to specify a particular type of statistical model (see Chapter \@ref(regression)) but they&#39;re such handy things that they&#39;ve spread. Formulas are now used in a lot of different contexts, so it makes sense to introduce them early.

Stated simply, a formula object is a variable, but it&#39;s a special type of variable that specifies a relationship between other variables. A formula is specified using the &quot;tilde operator&quot; `~`. A very simple example of a formula is shown below:^[Note that, when I write out the formula, R doesn&#39;t check to see if the `out` and `pred` variables actually exist: it&#39;s only later on when you try to use the formula for something that this happens.]
```{r}
formula1 &lt;- out ~ pred
formula1
```
The *precise* meaning of this formula depends on exactly what you want to do with it, but in broad terms it means &quot;the `out` (outcome) variable, analysed in terms of the `pred` (predictor) variable&quot;. That said, although the simplest and most common form of a formula uses the  &quot;one variable on the left, one variable on the right&quot; format, there are others. For instance, the following examples are all reasonably common
```{r}
formula2 &lt;-  out ~ pred1 + pred2   # more than one variable on the right
formula3 &lt;-  out ~ pred1 * pred2   # different relationship between predictors 
formula4 &lt;-  ~ var1 + var2         # a &#39;one-sided&#39; formula
```
and there are many more variants besides. Formulas are pretty flexible things, and so different functions will make use of different formats, depending on what the function is intended to do.


## Generic functions{#generics}

There&#39;s one really important thing that I omitted when I discussed functions earlier on in Section \@ref(usingfunctions), and that&#39;s the concept of a **_generic function_**. The two most notable examples that you&#39;ll see in the next few chapters are `summary()` and `plot()`, although you&#39;ve already seen an example of one working behind the scenes, and that&#39;s the `print()` function. The thing that makes generics different from the other functions is that their behaviour changes, often quite dramatically, depending on the `class()` of the input you give it. The easiest way to explain the concept is with an example. With that in mind, lets take a closer look at what the `print()` function actually does. I&#39;ll do this by creating a formula, and printing it out in a few different ways. First, let&#39;s stick with what we know:
```{r}
my.formula &lt;- blah ~ blah.blah    # create a variable of class &quot;formula&quot;
print( my.formula )               # print it out using the generic print() function
```
So far, there&#39;s nothing very surprising here. But there&#39;s actually a lot going on behind the scenes here. When I type `print( my.formula )`, what actually happens is the `print()` function checks the class of the `my.formula` variable. When the function discovers that the variable it&#39;s been given is a formula, it goes looking for a function called `print.formula()`, and then delegates the whole business of printing out the variable to the `print.formula()` function.^[For readers with a programming background: what I&#39;m describing is the very basics of how S3 methods work. However, you should be aware that R has two entirely distinct systems for doing object oriented programming, known as S3 and S4. Of the two, S3 is simpler and more informal, whereas S4 supports all the stuff that you might expect of a fully object oriented language. Most of the generics we&#39;ll run into in this book use the S3 system, which is convenient for me because I&#39;m still trying to figure out S4. ] For what it&#39;s worth, the name for a &quot;dedicated&quot; function like `print.formula()` that exists only to be a special case of a generic function like `print()` is a **_method_**, and the name for the process in which the generic function passes off all the hard work onto a method is called **_method dispatch_**. You won&#39;t need to understand the details at all for this book, but you do need to know the gist of it; if only because a lot of the functions we&#39;ll use are actually generics. Anyway, to help expose a little more of the workings to you, let&#39;s bypass the `print()` function entirely and call the formula method directly:
```{r eval=FALSE}
print.formula( my.formula )       # print it out using the print.formula() method

## Appears to be deprecated
```
There&#39;s no difference in the output at all. But this shouldn&#39;t surprise you because it was actually the `print.formula()` method that was doing all the hard work in the first place. The `print()` function itself is a lazy bastard that doesn&#39;t do anything other than select which of the methods is going to do the actual printing. 

Okay, fair enough, but you might be wondering what would have happened if `print.formula()` didn&#39;t exist? That is, what happens if there isn&#39;t a specific method defined for the class of variable that you&#39;re using? In that case, the generic function passes off the hard work to a &quot;default&quot; method, whose name in this case would be `print.default()`. Let&#39;s see what happens if we bypass the `print()` formula, and try to print out `my.formula` using the  `print.default()` function:
```{r}
print.default( my.formula )      # print it out using the print.default() method
```
Hm. You can kind of see that it is trying to print out the same formula, but there&#39;s a bunch of ugly low-level details that have also turned up on screen. This is because the `print.default()` method doesn&#39;t know anything about formulas, and doesn&#39;t know that it&#39;s supposed to be hiding the obnoxious internal gibberish that R produces sometimes. 

At this stage, this is about as much as we need to know about generic functions and their methods. In fact, you can get through the entire book without learning any more about them than this, so it&#39;s probably a good idea to end this discussion here.

## Getting help{#help}

The very last topic I want to mention in this chapter is where to go to find help. Obviously, I&#39;ve tried to make this book as helpful as possible, but it&#39;s not even close to being a comprehensive guide, and there&#39;s thousands of things it doesn&#39;t cover. So where should you go for help? 


### How to read the help documentation

I have somewhat mixed feelings about the help documentation in R. On the plus side, there’s a lot of it, and it’s very thorough. On the minus side, there’s a lot of it, and it’s very thorough. There’s so much help documentation that it sometimes doesn’t help, and most of it is written with an advanced user in mind. Often it feels like most of the help ﬁles work on the assumption that the reader already understands everything about R except for the speciﬁc topic that it’s providing help for. What that means is that, once you’ve been using R for a long time and are beginning to get a feel for how to use it, the help documentation is awesome. These days, I ﬁnd myself really liking the help ﬁles (most of them anyway). But when I ﬁrst started using R I found it very dense.

To some extent, there’s not much I can do to help you with this. You just have to work at it yourself; once you’re moving away from being a pure beginner and are becoming a skilled user, you’ll start ﬁnding the help documentation more and more helpful. In the meantime, I’ll help as much as I can by trying to explain to you what you’re looking at when you open a help ﬁle. To that end, let’s look at the help documentation for the `load()` function. To do so, I type either of the following:

```{r eval=FALSE}
?load 
help(&quot;load&quot;)
```

When I do that, R goes looking for the help ﬁle for the &quot;load&quot; topic. If it ﬁnds one, Rstudio takes it and displays it in the help panel. Alternatively, you can try a fuzzy search for a help topic

```{r eval=FALSE}
??load 
help.search(&quot;load&quot;)

```

This will bring up a list of possible topics that you might want to follow up in. Regardless, at some point you’ll ﬁnd yourself looking at an actual help ﬁle. And when you do, you’ll see there’s a quite a lot of stuﬀ written down there, and it comes in a pretty standardised format. So let’s go through it slowly, using the &quot;`load`&quot; topic as our example. Firstly, at the very top we see this:
```{block2, type=&#39;rmdnote&#39;}
&lt;table width=&quot;100%&quot; summary=&quot;page for load {base}&quot;&gt;&lt;tr&gt;&lt;td&gt;load {base}&lt;/td&gt;&lt;td style=&quot;text-align: right;&quot;&gt;R Documentation&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h4&gt;Reload Saved Datasets&lt;/h4&gt;

&lt;h5&gt;Description&lt;/h5&gt;

&lt;p&gt;Reload datasets written with the function &lt;code&gt;save&lt;/code&gt;.
&lt;/p&gt;
```


Fairly straightforward. The next section describes how the function is used:
```{block2, type=&#39;rmdnote&#39;}
&lt;h5&gt;Usage&lt;/h5&gt;

&lt;pre&gt;
load(file, envir = parent.frame(), verbose = FALSE)
&lt;/pre&gt;
```
In this instance, the usage section is actually pretty readable. It’s telling you that there are two arguments to the `load()` function: the ﬁrst one is called `file`, and the second one is called `envir`. It’s also telling you that there is a default value for the envir argument; so if the user doesn’t specify what the value of envir should be, then R will assume that `envir = parent.frame()`. In contrast, the file argument has no default value at all, so the user must specify a value for it. So in one sense, this section is very straightforward.

The problem, of course, is that you don’t know what the `parent.frame()` function actually does, so it’s hard for you to know what the `envir = parent.frame()` bit is all about. What you could do is then go look up the help documents for the `parent.frame()` function (and sometimes that’s actually a good idea), but often you’ll ﬁnd that the help documents for those functions are just as dense (if not more dense) than the help ﬁle that you’re currently reading. As an alternative, my general approach when faced with something like this is to skim over it, see if I can make any sense of it. If so, great. If not, I ﬁnd that the best thing to do is ignore it. In fact, the ﬁrst time I read the help ﬁle for the load() function, I had no idea what any of the `envir` related stuﬀ was about. But fortunately I didn’t have to: the default setting here (i.e., `envir = parent.frame()`) is actually the thing you want in about 99% of cases, so it’s safe to ignore it. 

Basically, what I’m trying to say is: don’t let the scary, incomprehensible parts of the help ﬁle intimidate you. Especially because there’s often some parts of the help ﬁle that will make sense. Of course, I guarantee you that sometimes this strategy will lead you to make mistakes... often embarrassing mistakes. But it’s still better than getting paralysed with fear. 

So, let’s continue on. The next part of the help documentation discusses each of the arguments, and what they’re supposed to do:
```{block2, type=&#39;rmdnote&#39;}
&lt;h5&gt;Arguments&lt;/h5&gt;

&lt;table summary=&quot;R argblock&quot;&gt;
&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;&lt;code&gt;file&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;a (readable binary-mode) &lt;a href=&quot;../../base/help/connection&quot;&gt;connection&lt;/a&gt; or a character string
giving the name of the file to load (when &lt;a href=&quot;../../base/help/tilde expansion&quot;&gt;tilde expansion&lt;/a&gt;
is done).&lt;/p&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;&lt;code&gt;envir&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;the environment where the data should be loaded.&lt;/p&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;&lt;code&gt;verbose&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;should item names be printed during loading?&lt;/p&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
```

Okay, so what this is telling us is that the `file` argument needs to be a string (i.e., text data) which tells R the name of the ﬁle to load. It also seems to be hinting that there’s other possibilities too (e.g., a “binary mode connection”), and you probably aren’t quite sure what “tilde expansion” means^[It’s extremely simple, by the way. We discussed it in Section 4.4, though I didn’t call it by that name. Tilde expansion is the thing where R recognises that, in the context of specifying a ﬁle location, the tilde symbol ~ corresponds to the user home directory (e.g., /Users/dan/).]. But overall, the meaning is pretty clear.

Turning to the `envir` argument, it’s now a little clearer what the Usage section was babbling about. The `envir` argument speciﬁes the name of an environment (see Section 4.3 if you’ve forgotten what environments are) into which R should place the variables when it loads the ﬁle. Almost always, this is a no-brainer: you want R to load the data into the same damn environment in which you’re invoking the `load()` command. That is, if you’re typing `load()` at the R prompt, then you want the data to be loaded into your workspace (i.e., the global environment). But if you’re writing your own function that needs to load some data, you want the data to be loaded inside that function’s private workspace. And in fact, that’s exactly what the `parent.frame()` thing is all about. It’s telling the `load()` function to send the data to the same place that the `load()` command itself was coming from. As it turns out, if we’d just ignored the envir bit we would have been totally safe. Which is nice to know. 

Moving on, next up we get a detailed description of what the function actually does:
```{block2, type=&#39;rmdnote&#39;}
&lt;h5&gt;Details&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;load&lt;/code&gt; can load &lt;span style=&quot;font-family: Courier New, Courier; color: #666666;&quot;&gt;&lt;b&gt;R&lt;/b&gt;&lt;/span&gt; objects saved in the current or any earlier
format.  It can read a compressed file (see &lt;code&gt;&lt;a href=&quot;../../base/help/save&quot;&gt;save&lt;/a&gt;&lt;/code&gt;)
directly from a file or from a suitable connection (including a call
to &lt;code&gt;&lt;a href=&quot;../../base/help/url&quot;&gt;url&lt;/a&gt;&lt;/code&gt;).
&lt;/p&gt;
&lt;p&gt;A not-open connection will be opened in mode &lt;code&gt;&quot;rb&quot;&lt;/code&gt; and closed
after use.  Any connection other than a &lt;code&gt;&lt;a href=&quot;../../base/help/gzfile&quot;&gt;gzfile&lt;/a&gt;&lt;/code&gt; or
&lt;code&gt;&lt;a href=&quot;../../base/help/gzcon&quot;&gt;gzcon&lt;/a&gt;&lt;/code&gt; connection will be wrapped in &lt;code&gt;&lt;a href=&quot;../../base/help/gzcon&quot;&gt;gzcon&lt;/a&gt;&lt;/code&gt;
to allow compressed saves to be handled: note that this leaves the
connection in an altered state (in particular, binary-only), and that
it needs to be closed explicitly (it will not be garbage-collected).
&lt;/p&gt;
&lt;p&gt;Only &lt;span style=&quot;font-family: Courier New, Courier; color: #666666;&quot;&gt;&lt;b&gt;R&lt;/b&gt;&lt;/span&gt; objects saved in the current format (used since &lt;span style=&quot;font-family: Courier New, Courier; color: #666666;&quot;&gt;&lt;b&gt;R&lt;/b&gt;&lt;/span&gt; 1.4.0)
can be read from a connection.  If no input is available on a
connection a warning will be given, but any input not in the current
format will result in a error.
&lt;/p&gt;
&lt;p&gt;Loading from an earlier version will give a warning about the
&amp;lsquo;magic number&amp;rsquo;: magic numbers &lt;code&gt;1971:1977&lt;/code&gt; are from &lt;span style=&quot;font-family: Courier New, Courier; color: #666666;&quot;&gt;&lt;b&gt;R&lt;/b&gt;&lt;/span&gt; &amp;lt;
0.99.0, and &lt;code&gt;RD[ABX]1&lt;/code&gt; from &lt;span style=&quot;font-family: Courier New, Courier; color: #666666;&quot;&gt;&lt;b&gt;R&lt;/b&gt;&lt;/span&gt; 0.99.0 to &lt;span style=&quot;font-family: Courier New, Courier; color: #666666;&quot;&gt;&lt;b&gt;R&lt;/b&gt;&lt;/span&gt; 1.3.1.  These are all
obsolete, and you are strongly recommended to re-save such files in a
current format.
&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;verbose&lt;/code&gt; argument is mainly intended for debugging.  If it
is &lt;code&gt;TRUE&lt;/code&gt;, then as objects from the file are loaded, their
names will be printed to the console.  If &lt;code&gt;verbose&lt;/code&gt; is set to
an integer value greater than one, additional names corresponding to
attributes and other parts of individual objects will also be printed.
Larger values will print names to a greater depth.
&lt;/p&gt;
&lt;p&gt;Objects can be saved with references to namespaces, usually as part of
the environment of a function or formula.  Such objects can be loaded
even if the namespace is not available: it is replaced by a reference
to the global environment with a warning.  The warning identifies the
first object with such a reference (but there may be more than one).
&lt;/p&gt;
```

Then it tells you what the output value of the function is:

```{block2, type=&#39;rmdnote&#39;}
&lt;h5&gt;Value&lt;/h5&gt;

&lt;p&gt;A character vector of the names of objects created, invisibly.
&lt;/p&gt;
```

This is usually a bit more interesting, but since the `load()` function is mainly used to load variables into the workspace rather than to return a value, it’s no surprise that this doesn’t do much or say much. Moving on, we sometimes see a few additional sections in the help ﬁle, which can be diﬀerent depending on what the function is:

```{block2, type=&#39;rmdnote&#39;}
&lt;h5&gt;Warning&lt;/h5&gt;

&lt;p&gt;Saved &lt;span style=&quot;font-family: Courier New, Courier; color: #666666;&quot;&gt;&lt;b&gt;R&lt;/b&gt;&lt;/span&gt; objects are binary files, even those saved with
&lt;code&gt;ascii = TRUE&lt;/code&gt;, so ensure that they are transferred without
conversion of end of line markers.  &lt;code&gt;load&lt;/code&gt; tries to detect such a
conversion and gives an informative error message.
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;load(&amp;lt;file&amp;gt;)&lt;/code&gt; replaces all existing objects with the same names
in the current environment (typically your workspace,
&lt;code&gt;&lt;a href=&quot;../../base/help/.GlobalEnv&quot;&gt;.GlobalEnv&lt;/a&gt;&lt;/code&gt;) and hence potentially overwrites important data.
It is considerably safer to use &lt;code&gt;envir = &lt;/code&gt; to load into a
different environment, or to &lt;code&gt;&lt;a href=&quot;../../base/help/attach&quot;&gt;attach&lt;/a&gt;(file)&lt;/code&gt; which
&lt;code&gt;load()&lt;/code&gt;s into a new entry in the &lt;code&gt;&lt;a href=&quot;../../base/help/search&quot;&gt;search&lt;/a&gt;&lt;/code&gt; path.
&lt;/p&gt;

&lt;h5&gt;Note&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;file&lt;/code&gt; can be a UTF-8-encoded filepath that cannot be translated to
the current locale.
&lt;/p&gt;
```

Yeah, yeah. Warning, warning, blah blah blah. Towards the bottom of the help ﬁle, we see something like this, which suggests a bunch of related topics that you might want to look at. These can be quite helpful:

```{block2, type=&#39;rmdnote&#39;}
&lt;h5&gt;See Also&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;&lt;a href=&quot;../../base/help/save&quot;&gt;save&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../base/help/download.file&quot;&gt;download.file&lt;/a&gt;&lt;/code&gt;; further
&lt;code&gt;&lt;a href=&quot;../../base/help/attach&quot;&gt;attach&lt;/a&gt;&lt;/code&gt; as wrapper for &lt;code&gt;load()&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;For other interfaces to the underlying serialization format, see
&lt;code&gt;&lt;a href=&quot;../../base/help/unserialize&quot;&gt;unserialize&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../base/help/readRDS&quot;&gt;readRDS&lt;/a&gt;&lt;/code&gt;.
&lt;/p&gt;
```

Finally, it gives you some examples of how to use the function(s) that the help ﬁle describes. These are supposed to be proper R commands, meaning that you should be able to type them into the console yourself and they’ll actually work. Sometimes it can be quite helpful to try the examples yourself. Anyway, here they are for the &quot;`load`&quot; help ﬁle:
```{block2, type=&#39;rmdnote&#39;}
&lt;h5&gt;Examples&lt;/h5&gt;

&lt;pre&gt;


## save all data
xx &amp;lt;- pi # to ensure there is some data
save(list = ls(all = TRUE), file= &quot;all.rda&quot;)
rm(xx)

## restore the saved values to the current environment
local({
   load(&quot;all.rda&quot;)
   ls()
})

xx &amp;lt;- exp(1:3)
## restore the saved values to the user&#39;s workspace
load(&quot;all.rda&quot;) ## which is here *equivalent* to
## load(&quot;all.rda&quot;, .GlobalEnv)
## This however annihilates all objects in .GlobalEnv with the same names !
xx # no longer exp(1:3)
rm(xx)
attach(&quot;all.rda&quot;) # safer and will warn about masked objects w/ same name in .GlobalEnv
ls(pos = 2)
##  also typically need to cleanup the search path:
detach(&quot;file:all.rda&quot;)

## clean up (the example):
unlink(&quot;all.rda&quot;)


## Not run: 
con &amp;lt;- url(&quot;http://some.where.net/R/data/example.rda&quot;)
## print the value to see what objects were created.
print(load(con))
close(con) # url() always opens the connection

## End(Not run)&lt;/pre&gt;
```
As you can see, they’re pretty dense, and not at all obvious to the novice user. However, they do provide good examples of the various diﬀerent things that you can do with the `load()` function, so it’s not a bad idea to have a look at them, and to try not to ﬁnd them too intimidating.

### Other resources

- The Rseek website (www.rseek.org). One thing that I really find annoying about the R help documentation is that it&#39;s hard to search properly. When coupled with the fact that the documentation is dense and highly technical, it&#39;s often a better idea to search or ask online for answers to your questions. With that in mind, the Rseek website is great: it&#39;s an R specific search engine. I find it really useful, and it&#39;s almost always my first port of call when I&#39;m looking around.
- The R-help mailing list (see http://www.r-project.org/mail.html for details). This is the official R help mailing list. It can be very helpful, but it&#39;s *very* important that you do your homework before posting a question. The list gets a lot of traffic. While the people on the list try as hard as they can to answer questions, they do so for free, and you *really* don&#39;t want to know how much money they could charge on an hourly rate if they wanted to apply market rates. In short, they are doing you a favour, so be polite. Don&#39;t waste their time asking questions that can be easily answered by a quick search on Rseek (it&#39;s rude), make sure your question is clear, and all of the relevant information is included. In short, read the posting guidelines carefully (http://www.r-project.org/posting-guide.html), and make use of the `help.request()` function that R provides to check that you&#39;re actually doing what you&#39;re expected.


## Summary

This chapter continued where Chapter \@ref(introR) left off. The focus was still primarily on introducing basic R concepts, but this time at least you can see how those concepts are related to data analysis:

- [Installing, loading and updating packages](#packageinstall). Knowing how to extend the functionality of R by installing and using packages is critical to becoming an effective R user
- Getting around. Section \@ref(workspace) talked about how to manage your workspace and how to keep it tidy. Similarly, Section \@ref(navigation) talked about how to get R to interact with the rest of the file system.
- [Loading and saving data](#load). Finally, we encountered actual data files. Loading and saving data is obviously a crucial skill, one we discussed in Section \@ref(load).
- [Useful things to know about variables](#useful). In particular, we talked about special values, element names and classes.
- More complex types of variables. R has a number of important variable types that will be useful when analysing real data. I talked about factors in Section \@ref(factors), data frames in Section \@ref(dataframes), lists in Section \@ref(lists) and formulas in Section \@ref(formulas).
- [Generic functions](#generics). How is it that some function seem to be able to do lots of different things? Section \@ref(generics) tells you how.
- [Getting help](#help). Assuming that you&#39;re not looking for counselling, Section \@ref(help) covers several possibilities. If you are looking for counselling, well, this book really can&#39;t help you there. Sorry. 

Taken together, Chapters \@ref(introR) and \@ref(mechanics) provide enough of a background that you can finally get started doing some statistics! Yes, there&#39;s a lot more R concepts that you ought to know (and we&#39;ll talk about some of them in Chapters\@ref(datahandling) and\@ref(scripting)), but I think that we&#39;ve talked quite enough about programming for the moment. It&#39;s time to see how your experience with programming can be used to do some data analysis...
</pre></div>
</div>
</div>
</div>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="note1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Notice that I used <code class="docutils literal notranslate"><span class="pre">print(keeper)</span></code> rather than just typing <code class="docutils literal notranslate"><span class="pre">keeper</span></code>. Later on in the text I’ll sometimes use the <code class="docutils literal notranslate"><span class="pre">print()</span></code> function to display things because I think it helps make clear what I’m doing, but in practice people rarely do this.</p>
</dd>
<dt class="label" id="note2"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>There are some subtle differences between libraries, packages, and modules, but we don’t need to concern ourselves with these here, and I may well mix up these words in the text. The key thing is, they are bits of code that we need to import to make stuff happen in Python.</p>
</dd>
<dt class="label" id="note3"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>https://xkcd.com/353/</p>
</dd>
<dt class="label" id="note4"><span class="brackets">4</span><span class="fn-backref">(<a href="#id4">1</a>,<a href="#id5">2</a>)</span></dt>
<dd><p>Basically, the reason is that there are thousands of libraries, and probably thousands of authors of libraries, and no-one really knows what all of them do. Keeping the installation separate from the loading minimizes the chances that two libraries will interact with each other in a nasty way.</p>
</dd>
</dl>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="02.01-getting_started_with_python.html" title="previous page"><span class="section-number">1. </span>Getting Started with Python</a>
    <a class='right-next' id="next-link" href="03.01-descriptives.html" title="next page"><span class="section-number">1. </span>Descriptive statistics</a>

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Danielle Navarro and Ethan Weed<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>